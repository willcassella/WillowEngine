// MemoryBlock.h - Copyright 2013-2016 Will Cassella, All Rights Reserved
#pragma once

#include <cassert>
#include <utility>
#include "../config.h"
#include "../Forwards/Memory.h"
#include "../Forwards/Reflection.h"

/////////////////
///   Types   ///

/** Indicates the status of the value contained in a memory block. */
enum class MemoryBlockValueStatus : byte
{
	/** The block has been created, but it does not have a valid value.
	* The memory returned by 'GetData' will be zeroed out. */
	Uninitialized,
	
	/* The block has been created, and the value has been constructed and is ready for use. */
	Constructed,

	/* The block has been created, but the value has been deconstructed. Once all references have cleared, this block will be freed. */
	Destroyed
};

/** Enum of all possible forms of ownership. */
enum class OwnershipType : byte
{
	/** The ownership has not been determined yet, most likely because nothing has taken ownership, 
	* or it has no owner (as is the case for stack and static variables). */
	Undetermined,

	/** There is only one owner for this object (UniquePtr), and once that goes out of scope this object will be destroyed. */
	Unique,

	/** This object has multiple owners (SharedPtr), and once they all go out of scope this object will be destroyed. */
	Shared
};

/** Structure holding reference count information.
* NOTE: A "ref" in this context is any sort of smart pointer/reference.
* NOTE: Currently this class has a lot of assert stuff in it. While this is helpful, most of it is totally
* unnecessary and just slows down the program. Once I have time to thoroughly test this, I will remove most of them. */
struct CORE_API ReferenceCounter final
{
	///////////////////
	///   Methods   ///
public:

	/** Returns the total number of references. */
	FORCEINLINE uint32 GetTotalRefs() const
	{
		return GetNumOwnerRefs() + GetNumWeakRefs() + GetNumBorrowedRefs();
	}

	/** Returns the type of ownership that this object is managed with. */
	FORCEINLINE OwnershipType GetOwnership() const
	{
		return _ownership;
	}

	/** Sets the type of ownership this object has.
	* NOTE: This sets the owner ref count to '1' (you can't determine the type of ownership without an active owner anyway).
	* WARNING: 'type' may not be equal to 'Ownership::Undetermined'.
	* WARNING: This object must currently have 'Undeteremined' ownership. */
	void SetOwnership(OwnershipType type)
	{
		assert(type != OwnershipType::Undetermined /* You can't set ownership to be undetermined. */);
		assert(_ownership == OwnershipType::Undetermined /* Objects may not have their ownership changed, unless it was previously undetermined */);

		_ownership = type;
		_numOwnerRefs = 1;
	}

	/** Returns the number of owning references to this.
	* Ex: With Unique, this should be at most '1'. */
	FORCEINLINE uint32 GetNumOwnerRefs() const
	{
		return _numOwnerRefs;
	}

	/** Increments the owner ref count.
	* WARNING: Ownership may not be undetermined. 
	* WARNING: Ownership may not be unique. */
	void AddOwnerRef()
	{
		assert(_ownership != OwnershipType::Undetermined);
		assert(_ownership != OwnershipType::Unique);
		++_numOwnerRefs;
	}

	/** Decrements the owner reference count.
	* WARNING: The owner reference count must be greater than '0'. */
	void ReleaseOwnerRef()
	{
		assert(_numOwnerRefs > 0 /* You can't decrement the ownership count below '0'. */);
		--_numOwnerRefs;
	}

	/** Returns the number of borrowed references to this object.
	* Borrowed references are generated by dereferencing WeakPtrs. */
	FORCEINLINE uint32 GetNumBorrowedRefs() const
	{
		return _numBorrowedRefs;
	}

	/** Increments the number of borrowed references. 
	* WARNING: The number of weak references must be greater than '0'. */
	void AddBorrowedRef()
	{
		assert(_numWeakRefs > 0 /* You can't have borrowed references without weak references. */);

		++_numBorrowedRefs;
	}

	/** Decrements the number of borrowed references. 
	* WARNING: The number of borrowed references must be greater than '0'. */
	void ReleaseBorrowedRef()
	{
		assert(_numBorrowedRefs > 0 /* You may not decrement the number of borrowed references below '0'. */);

		--_numBorrowedRefs;
	}

	/** Returns the number of weak references to this object. */
	FORCEINLINE uint32 GetNumWeakRefs() const
	{
		return _numWeakRefs;
	}

	/** Increments the number of weak references. */
	void AddWeakRef()
	{
		++_numWeakRefs;
	}

	/** Decrements the number of weak references.
	* WARNING: The number of weak references must be greater than '0'. */
	void ReleaseWeakRef()
	{
		assert(_numWeakRefs > 0 /* You may not decrement the number of weak references below '0'. */);

		--_numWeakRefs;
	}

	////////////////
	///   Data   ///
private:

	OwnershipType _ownership = OwnershipType::Undetermined;
	uint32 _numOwnerRefs = 0;
	uint32 _numBorrowedRefs = 0;
	uint32 _numWeakRefs = 0;
};

/** Structure located at the start of every memory block. */
struct CORE_API MemoryBlockController final
{
	///////////////////////
	///   Information   ///
public:

	/** Only the MemoryManager is allowed to construct MemoryBlockControllers. */
	friend MemoryManager;

	////////////////////////
	///   Constructors   ///
private:

	MemoryBlockController(const TypeInfo& type)
		: _type(&type), _status(MemoryBlockValueStatus::Uninitialized)
	{
		// All done
	}
	MemoryBlockController(const MemoryBlockController& copy) = delete;
	MemoryBlockController(MemoryBlockController&& move) = delete;
	~MemoryBlockController() = default;

	///////////////////
	///   Methods   ///
public:

	/** Returns the status of the value in this MemoryBlock. */
	FORCEINLINE MemoryBlockValueStatus GetStatus() const
	{
		return _status;
	}

	/** Returns the type that this MemoryBlock was created for. */
	FORCEINLINE const TypeInfo& GetAllocatedType() const
	{
		return *_type;
	}

	/** Returns the refcounter for this MemoryBlock. */
	FORCEINLINE ReferenceCounter& GetRefCounter() const
	{
		return _refCounter;
	}

	/** Returns a pointer to the data allocated within this MemoryBlock.
	* NOTE: You should understand the state of the value constructed within this first, via 'GetStatus()'. */
	FORCEINLINE void* GetData()
	{
		return this + 1;
	}

	/** Returns a pointer to the data allocated within this MemoryBlock.
	* NOTE: You should understand the state of the value constructed within this first, via 'GetStatus()'. */
	FORCEINLINE const void* GetData() const
	{
		return this + 1;
	}

	/** Returns the data allocated within the MemoryBlock as a Variant.
	* WARNING: The status for this MemoryBlock must be "Constructed". */
	Variant GetDataAsVariant();

	/** Returns the data allocated within the MemoryBlock as an ImmutableVariant.
	* WARNING: The status for this MemoryBlock must be "Constructed". */
	ImmutableVariant GetDataAsVariant() const;

	/** Calls the destructor for the value allocated within this MemoryBlock.
	* WARNING: The status of this MemoryBlock must be "Constructed". 
	* WARNING: This block must have no remaining owning references.
	* WARNING: This block must have no remaining borrowed references. */
	void Destroy();

	/** Constructs the value allocated wihin this MemoryBlock.
	* WARNING: The status of this MemoryBlock must be "Uninitalized". */
	template <typename T, typename ... ArgT>
	void Construct(ArgT&& ... args)
	{
		assert(_status == MemoryBlockValueStatus::Uninitialized);
		assert(*_type == TypeOf<T>());

		new (GetData()) T(std::forward<ArgT>(args)...);

		_status = MemoryBlockValueStatus::Constructed;
	}

	/////////////////////
	///   Operators   ///
public:

	MemoryBlockController& operator=(const MemoryBlockController& copy) = delete;
	MemoryBlockController& operator=(MemoryBlockController&& move) = delete;

	////////////////
	///   Data   ///
private:

	mutable ReferenceCounter _refCounter;
	const TypeInfo* _type;
	MemoryBlockValueStatus _status;
};
